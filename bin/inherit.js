/**
 * inherit() 返回一个继承自原型对象p的属性的新对象
 * inherit()函数的一个用途就是防止库函数无意间修改不受控制的对象。不是将对象直接作为参数传入函数，
 * 而是将它的继承对象传入函数；但函数读取继承对象的属性时，实际上读取的是继承来的值；如果给继承对象的属性赋值，
 * 则这些属性只会影响这个继承对象自身，而非原始对象的属性值。
 * 假设要查询对象o的属性x,如果o中不存在x,那么将会继续在o的原型对象中查询属性x。
 *      如果原型对象中也没有x,但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者找到一个没有原型的对象为止。
 *      在此过程中，对象属性的查找时沿着原型链查找，对象通过原型链继承属性。
 * 假设给对象o的属性x赋值，首先检查原型链判断是否允许赋值操作；如果o继承自一个只读属性x,那么操作是不允许的。
 *      如果o中已经有属性x(x不是继承来的)，那么就改变o中属性x的值；
 *      如果o中不存在x(不存在自有属性x)，那么赋值操作就给o添加一个新属性x；这个添加的自有属性x会覆盖继承属性x。
 * 所以，原型链只有在查找对象属性时起作用，而在修改对象属性或者添加对象属性时不起作用；因为在子类中修改属性值的操作影响到原型链上的父类的属性的值。
 * 此特定可以让我们有选择地覆盖继承的属性。
 * 对象的属性赋值操作都在原始对象中进行；有一个例外，如果o继承获得了属性x,而这个属性在原型中是一个具有setter方法的accessor属性，
 * 那么在给o的属性x赋值时会使用o调用setter方法而不是给o创建一个属性x。（注意;setter方法是由o调用的，而不是由定义此属性的原型对象调用的，所以仍然不会修改原型链的属性值）。
 */
function inherit(p) {
    if (p == null) throw TypeError();
    if (Object.create)
        return Object.create(p);
    let t = typeof p;
    if (t !== 'object' && t !== 'function')
        throw TypeError();

    function F() {
    }

    F.prototype = p;
    return new F();
}

exports.inherit = inherit;